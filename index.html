<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Airplane Fighter</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', Courier, monospace; }
        #gameCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #hudCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; pointer-events: none; }
        #overlay {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; color: white; background: rgba(0,0,0,0.8);
            padding: 30px; border-radius: 15px; z-index: 10;
            border: 2px solid #0f0;
        }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #0f0; font-size: 24px; z-index: 11;
        }
        button {
            padding: 15px 30px; font-size: 20px; cursor: pointer;
            background: #0f0; color: black; border: none; font-weight: bold;
            margin-top: 20px;
        }
        button:hover { background: #0c0; }
    </style>
</head>
<body>
    <div id="loading">INITIALIZING SYSTEMS... 0%</div>
    <div id="overlay" style="display: none;">
        <h1 id="status-title">AIR COMBAT COMMAND</h1>
        <p id="status-msg">MISSION: DESTROY ENEMY FIGHTER & LAND AT BASE</p>
        <p style="font-size: 14px;">MOUSE: Steering & Pitch | CLICK: Shoot | SHIFT/CTRL: Throttle | C: Camera</p>
        <button id="start-btn">ENGAGE</button>
    </div>
    <canvas id="gameCanvas"></canvas>
    <canvas id="hudCanvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
    const canvas = document.getElementById('gameCanvas');
    const hudCanvas = document.getElementById('hudCanvas');
    const ctx = hudCanvas.getContext('2d');
    const overlay = document.getElementById('overlay');
    const loadingDiv = document.getElementById('loading');
    const startBtn = document.getElementById('start-btn');

    // Resize canvases
    function resize() {
        const w = window.innerWidth;
        const h = window.innerHeight;
        canvas.width = w; canvas.height = h;
        hudCanvas.width = w; hudCanvas.height = h;
        if (camera) {
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
        }
        if (renderer) renderer.setSize(w, h);
    }
    window.addEventListener('resize', resize);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x88aabb);
    scene.fog = new THREE.FogExp2(0x88aabb, 0.0003);

    const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 15000);
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    resize();

    let planeModel;
    let player;
    let npc;
    let bullets = [];
    let gameState = 'DESTROY_NPC';
    let gameActive = false;
    let worldSize = 10000;

    const keys = {};
    window.addEventListener('keydown', e => keys[e.code] = true);
    window.addEventListener('keyup', e => keys[e.code] = false);
    window.addEventListener('mousedown', (e) => { if (e.button === 0) keys['Mouse0'] = true; });
    window.addEventListener('mouseup', (e) => { if (e.button === 0) keys['Mouse0'] = false; });

    canvas.addEventListener('mousedown', () => {
        if (gameActive) canvas.requestPointerLock();
    });

    window.addEventListener('mousemove', e => {
        if (document.pointerLockElement === canvas && player) {
            // Steering: Mouse X rotates Roll/Yaw, Mouse Y rotates Pitch
            player.pitch += e.movementY * 0.002;
            player.roll -= e.movementX * 0.004;
        }
    });

    startBtn.addEventListener('click', () => {
        overlay.style.display = 'none';
        gameActive = true;
        canvas.requestPointerLock();
    });

    class Plane {
        constructor(isNPC = false) {
            this.isNPC = isNPC;
            this.mesh = planeModel.clone();
            scene.add(this.mesh);

            this.position = new THREE.Vector3(isNPC ? 500 : 0, 500, isNPC ? -800 : 0);
            this.rotation = new THREE.Euler(0, isNPC ? Math.PI : 0, 0, 'YXZ');
            this.speed = 40;
            this.health = 100;
            this.ammo = 1000;
            this.lastShot = 0;
            this.pitch = 0;
            this.roll = 0;
            this.yaw = isNPC ? Math.PI : 0;
        }

        update(dt) {
            if (!gameActive && !this.isNPC) return;

            if (this.isNPC) this.updateAI(dt);
            else this.updatePlayer(dt);

            const gravity = 0.15;
            const dragCoeff = 0.005;
            const liftCoeff = 0.12;

            const forward = new THREE.Vector3(0, 0, 1).applyEuler(this.rotation);

            // Physics: Speed changes with pitch
            this.speed -= forward.y * gravity * 15 * dt;
            this.speed -= this.speed * dragCoeff * dt;

            if (this.speed < 15) this.pitch -= 0.02 * dt; // Stall
            this.speed = Math.max(5, Math.min(120, this.speed));

            this.rotation.set(this.pitch, this.yaw, this.roll, 'YXZ');

            const moveVec = forward.clone().multiplyScalar(this.speed * dt);
            this.position.add(moveVec);

            // Lift and Gravity
            this.position.y -= gravity * 5 * dt;
            if (this.speed > 30) this.position.y += (this.speed - 30) * liftCoeff * dt;

            this.mesh.position.copy(this.position);
            this.mesh.rotation.copy(this.rotation);

            // Terrain / Boundary
            const groundH = getTerrainHeight(this.position.x, this.position.z);
            if (this.position.y < groundH + 1) {
                if (!this.isNPC && gameState === 'LAND' && Math.abs(this.position.x) < 20 && Math.abs(this.position.z - 1500) < 300) {
                    this.checkLanding();
                } else {
                    this.explode();
                }
            }

            if (this.health <= 0) this.explode();
        }

        updatePlayer(dt) {
            // Keyboard additions
            if (keys['KeyW'] || keys['ArrowUp']) this.pitch -= 1.0 * dt;
            if (keys['KeyS'] || keys['ArrowDown']) this.pitch += 1.0 * dt;
            if (keys['KeyA'] || keys['ArrowLeft']) this.roll += 2.0 * dt;
            if (keys['KeyD'] || keys['ArrowRight']) this.roll -= 2.0 * dt;

            // Auto-level roll if not steering
            if (!keys['KeyA'] && !keys['KeyD'] && !keys['ArrowLeft'] && !keys['ArrowRight'] && Math.abs(this.roll) > 0.01 && !document.pointerLockElement) {
                this.roll *= (1 - 2 * dt);
            }

            this.yaw += this.roll * 0.5 * dt;
            if (keys['ShiftLeft']) this.speed += 10 * dt;
            if (keys['ControlLeft']) this.speed -= 10 * dt;

            if (keys['Space'] || keys['Mouse0']) this.shoot();
            this.pitch = Math.max(-1.4, Math.min(1.4, this.pitch));
        }

        updateAI(dt) {
            if (!player) return;
            const targetPos = player.position;
            const dist = this.position.distanceTo(targetPos);
            const localTarget = targetPos.clone().applyMatrix4(new THREE.Matrix4().copy(this.mesh.matrixWorld).invert());

            if (localTarget.x > 5) this.roll -= 1.0 * dt;
            else if (localTarget.x < -5) this.roll += 1.0 * dt;
            else this.roll *= 0.9;

            if (localTarget.y > 5) this.pitch -= 0.5 * dt;
            else if (localTarget.y < -5) this.pitch += 0.5 * dt;

            this.yaw += this.roll * 0.5 * dt;
            if (this.position.y < getTerrainHeight(this.position.x, this.position.z) + 100) this.pitch -= 1.0 * dt;

            const forward = new THREE.Vector3(0, 0, 1).applyEuler(this.rotation);
            const dirToPlayer = targetPos.clone().sub(this.position).normalize();
            if (dist < 800 && forward.dot(dirToPlayer) > 0.9) this.shoot();
        }

        shoot() {
            const now = Date.now();
            if (now - this.lastShot > 150 && this.ammo > 0) {
                const forward = new THREE.Vector3(0, 0, 1).applyEuler(this.rotation);
                bullets.push({
                    pos: this.position.clone().add(forward.clone().multiplyScalar(10)),
                    vel: forward.clone().multiplyScalar(250),
                    owner: this,
                    life: 2.0
                });
                this.lastShot = now;
                this.ammo--;
            }
        }

        checkLanding() {
            if (this.speed < 50) {
                gameActive = false;
                document.exitPointerLock();
                showStatus("MISSION COMPLETE", "You have successfully landed.");
            } else {
                this.explode();
            }
        }

        explode() {
            this.health = 0;
            if (this.isNPC) {
                scene.remove(this.mesh);
                npc = null;
                gameState = 'LAND';
            } else {
                gameActive = false;
                document.exitPointerLock();
                showStatus("GAME OVER", "Your aircraft was destroyed.");
            }
        }
    }

    function getTerrainHeight(x, z) {
        const dist = Math.sqrt(x*x + z*z);
        if (dist > worldSize * 0.45) return (dist - worldSize * 0.45) * 0.8;
        return Math.sin(x * 0.01) * Math.cos(z * 0.01) * 15;
    }

    function createWorld() {
        const geo = new THREE.PlaneGeometry(worldSize, worldSize, 100, 100);
        const pos = geo.attributes.position;
        for (let i = 0; i < pos.count; i++) {
            pos.setZ(i, getTerrainHeight(pos.getX(i), pos.getY(i)));
        }
        geo.computeVertexNormals();
        const mat = new THREE.MeshStandardMaterial({ color: 0x2d5a27, flatShading: true });
        const terrain = new THREE.Mesh(geo, mat);
        terrain.rotation.x = -Math.PI / 2;
        scene.add(terrain);

        // Runway
        const rGroup = new THREE.Group();
        const rGeo = new THREE.PlaneGeometry(40, 600);
        const rMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
        const runway = new THREE.Mesh(rGeo, rMat);
        runway.rotation.x = -Math.PI / 2;
        rGroup.add(runway);
        for (let i = -300; i <= 300; i += 50) {
            const l = new THREE.Mesh(new THREE.SphereGeometry(1.5), new THREE.MeshBasicMaterial({color: 0x00ff00}));
            l.position.set(-22, 1, i);
            rGroup.add(l);
            const r = l.clone(); r.position.x = 22;
            rGroup.add(r);
        }
        rGroup.position.set(0, 1.5, 1500);
        scene.add(rGroup);

        scene.add(new THREE.AmbientLight(0xffffff, 0.8));
        const sun = new THREE.DirectionalLight(0xffffff, 1.2);
        sun.position.set(1000, 2000, 1000);
        scene.add(sun);
    }

    async function loadGame() {
        try {
            const loader = new THREE.GLTFLoader();
            const gltf = await new Promise((res, rej) => {
                loader.load('fighterjet1.glb', res, (xhr) => {
                    loadingDiv.innerText = `LOADING FIGHTER... ${Math.round(xhr.loaded / (xhr.total || 1000000) * 100)}%`;
                }, rej);
            });
            planeModel = gltf.scene;
            const box = new THREE.Box3().setFromObject(planeModel);
            const size = box.getSize(new THREE.Vector3()).length();
            const scale = 8 / size;
            planeModel.scale.set(scale, scale, scale);

            loadingDiv.style.display = 'none';
            overlay.style.display = 'block';

            createWorld();
            player = new Plane(false);
            npc = new Plane(true);
            animate();
        } catch (err) {
            console.error(err);
            loadingDiv.innerText = "FAILED TO LOAD fighterjet1.glb";
        }
    }

    function showStatus(title, msg) {
        overlay.style.display = 'block';
        document.getElementById('status-title').innerText = title;
        document.getElementById('status-msg').innerText = msg;
    }

    let camMode = 0;
    window.addEventListener('keydown', e => { if(e.code === 'KeyC') camMode = (camMode + 1) % 3; });

    function animate() {
        requestAnimationFrame(animate);
        const dt = 1/60;

        player.update(dt);
        if (npc) npc.update(dt);

        bullets.forEach((b, i) => {
            b.pos.add(b.vel.clone().multiplyScalar(dt));
            b.life -= dt;
            if (b.life <= 0) bullets.splice(i, 1);
            else {
                if (npc && b.owner === player && b.pos.distanceTo(npc.position) < 20) {
                    npc.health -= 10; bullets.splice(i, 1);
                }
                if (b.owner === npc && b.pos.distanceTo(player.position) < 15) {
                    player.health -= 5; bullets.splice(i, 1);
                }
            }
        });

        if (camMode === 0) {
            const off = new THREE.Vector3(0, 5, -15).applyEuler(player.rotation);
            camera.position.lerp(player.position.clone().add(off), 0.1);
            camera.lookAt(player.position);
        } else if (camMode === 1) {
            const off = new THREE.Vector3(0, 1.5, 3).applyEuler(player.rotation);
            camera.position.copy(player.position.clone().add(off));
            camera.lookAt(player.position.clone().add(new THREE.Vector3(0,0,10).applyEuler(player.rotation)));
        } else {
            camera.position.set(player.position.x, player.position.y + 100, player.position.z);
            camera.lookAt(player.position);
        }

        renderer.render(scene, camera);
        drawHUD();
    }

    function drawHUD() {
        ctx.clearRect(0,0,hudCanvas.width, hudCanvas.height);
        if (!player) return;

        ctx.fillStyle = '#0f0';
        ctx.font = 'bold 20px Courier New';
        ctx.fillText(`SPD: ${Math.round(player.speed * 3)}`, 20, 40);
        ctx.fillText(`ALT: ${Math.round(player.position.y * 5)}`, 20, 70);
        ctx.fillText(`AMMO: ${player.ammo}`, 20, 100);

        ctx.fillText(`HP:`, 20, 130);
        ctx.strokeStyle = '#0f0';
        ctx.strokeRect(60, 115, 100, 15);
        ctx.fillRect(60, 115, Math.max(0, player.health), 15);

        ctx.fillStyle = 'yellow';
        ctx.fillText(`OBJ: ${gameState === 'DESTROY_NPC' ? 'DESTROY ENEMY' : 'LAND AT BASE'}`, 20, 170);

        const target = (gameState === 'DESTROY_NPC' && npc) ? npc.position : new THREE.Vector3(0, 1.5, 1500);
        const dist = Math.round(player.position.distanceTo(target));
        ctx.fillText(`DIST: ${dist}m`, 20, 200);

        const vec = target.clone().project(camera);
        if (vec.z < 1) {
            const x = (vec.x + 1) / 2 * hudCanvas.width;
            const y = -(vec.y - 1) / 2 * hudCanvas.height;
            ctx.strokeStyle = 'red';
            ctx.strokeRect(x - 20, y - 20, 40, 40);
        }

        ctx.strokeStyle = 'rgba(0, 255, 0, 0.5)';
        ctx.beginPath();
        ctx.arc(hudCanvas.width/2, hudCanvas.height/2, 20, 0, Math.PI*2);
        ctx.moveTo(hudCanvas.width/2 - 30, hudCanvas.height/2);
        ctx.lineTo(hudCanvas.width/2 + 30, hudCanvas.height/2);
        ctx.moveTo(hudCanvas.width/2, hudCanvas.height/2 - 30);
        ctx.lineTo(hudCanvas.width/2, hudCanvas.height/2 + 30);
        ctx.stroke();
    }

    loadGame();
    </script>
</body>
</html>
